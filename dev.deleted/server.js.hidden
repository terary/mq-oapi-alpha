'use strict';

//let isThisModule =  false;

const THIS_IS_MODULE = require.main === module;
// if (require.main !== module) {
//     isThis =  true;
//     console.log('required as a module');
// } else {
//     console.log('called directly');
// }


const MONGO_CONNECT_OPTIONS = {  
        useNewUrlParser: true, 
        connectTimeoutMS:5000,  
        useCreateIndex: true, 
        useFindAndModify:false,
        useUnifiedTopology: true  
    };
// const mq = require('../src/classes/monqade-ext/monqade-express')
const MqSchemaExt = require('../src/classes/monqade-ext/monqade-express')
const MonqadeExpressOapi = require('../src/classes/monqade-ext/monqade-express-oapi')


const dictSchemaDef = require('monqade-dev-schemas').dictionary;

const mq2wm = require('./monqade-to-webmethods');
const express = require("express");
const morgan = require('morgan')
const bodyParser = require('body-parser')

const app = express();

// app.use( bodyParser.json() );       //
app.use(express.json()); // instead of bodyParser
app.use(morgan('combined')); 

const port = process.env.PORT || "8000";
const mongoose = require('mongoose');
app.get("/", (req, res) => {
  res.status(200).send("WHATABYTE: Food For Devs");
});

const OapiDocument = require('../src/classes/oapi/document/')
const {FieldType, FieldTypeCollection, WebMethod }  = require('../src/classes/web-method/');
const {webMethods, oapiDocument} = require('./make-web-methods');
const echoResponse = {'200':{$ref:'#/components/schemas/Empty'}};


const fnWmGetOpenAPI = (req,res)=>{res.send(
    oapiDocument.toJSON()
    )}
//get in query
let mwDescription = `
    path definition holds parameter definitions
    form: example.com/resource?p1=v1&p2=v2...
`;
//const wmGetOAPIDoc = new WebMethod('get','/openapi','openapidoc',  fnWmGetOpenAPI,[], echoResponse, 'echos the message ',mwDescription);
const wmGetOAPIDoc = new WebMethod('get','/openapi','openapidoc',  fnWmGetOpenAPI,undefined, echoResponse, 'echos the message ',mwDescription);
oapiDocument.addPath(wmGetOAPIDoc.oapiPath);
webMethods[wmGetOAPIDoc.oapiOperationId] = wmGetOAPIDoc;

//app.get('/openapi',fnWmGetOpenAPI)
app[wmGetOAPIDoc.httpMethod](wmGetOAPIDoc.endpoint, wmGetOAPIDoc.execFn);

mongoose.createConnection('mongodb://localhost/oapi-exp-mq', MONGO_CONNECT_OPTIONS).then(conn=>{
    const dictSchemaDef = require('monqade-dev-schemas').dictionary;


    //example: 
    //      adding a non Monqade function, oapiDoc+express
    const fnServerTime = function(req,res){res.send({serverTime:new Date()})}
    const wmServerTime = new WebMethod('get','/serverTime','serverTime',fnServerTime,undefined, OapiDocument.genericResponses(),'summary','desc')
    oapiDocument.addPath(wmServerTime.oapiPath)
    app[wmServerTime.httpMethod](wmServerTime.endpoint,wmServerTime.execFn);

    app.use(function(req,res,next){
        next();
    });
    //example: 
    //      adding a non Monqade function with parameters, oapiDoc+express
    addForeignTimeEndpoint(app,oapiDocument);  // adds via side-effect, outside of convents - but want to keep things concise





    // this will change
    //           oapiDocument.merger(mqSchema1.oapiDoc, mqSchema2.oapiDoc) or similar
    //           app.use(mqSchema.buildRoutes())
    //                  and/or
    //           mqSchema.appendRouts(app)
    const mqSchema= new MonqadeExpressOapi(dictSchemaDef.paths,dictSchemaDef.options,conn,{doUpsertOne:{enabled:true}});

    mqSchema.appendRouter(app, oapiDocument)

    oapiDocument.merge(mqSchema.oapiDocument);
    oapiDocument.merge(MonqadeExpressOapi.oapiMonqadeUniversal());

    if( THIS_IS_MODULE ){
        app.listen(port, () => {
            console.log(`Listening to requests on http://localhost:${port}`);
          });
    }
      
}).catch(e=>{
    console.log('Caught mongoose connection error:', e);
})


function addForeignTimeEndpoint(app,oapiDoc){
    // Example:
    //      create endpoint (webMethod) describing input and output parameters
    //      document and add express route 

    const fnDescription = 'valid IANA timezone (https://www.iana.org/time-zones) (https://gist.github.com/aviflax/a4093965be1cd008f172)'
    const tzDescription = 'valid IANA timezone'
    const fnSummary = 'Return current time of the given timezone';
    const IS_REQUIRED = true;

    const responseFields = new FieldTypeCollection();
    responseFields.addFields(new FieldType('timezone','string'),new FieldType('currentTime','date'))

    const oapiResponseObject =     Object.assign({},OapiDocument.genericResponses(),responseFields.as200Response());
    const  fnParameters = new FieldTypeCollection();
    fnParameters.addFields(new FieldType('timezone','string', IS_REQUIRED,{description:tzDescription}));

    
    const fnGetForeignTime = function(req,res){
        const tz = req.query.timezone || "Australia/Brisbane";
        const timeString = new Date().toLocaleString("en-US", {timeZone: tz});
        const aestTime = new Date(timeString); 
        res.send({currentTime:timeString, timezone:tz})
    }


    const wmForeignTime = new WebMethod(
                                        'get',              // httpMethod
                                        '/foreignTime',     // endpoint
                                        'foreignTime',      // operationId (unique within OAPI Doc)
                                        fnGetForeignTime,   // to be executed upon request
                                        fnParameters, // inputs
                                        oapiResponseObject,  // outputs
                                        fnSummary,          // human readable
                                        fnDescription      // human readable
                                        );

    oapiDocument.addPath(wmForeignTime.oapiPath)
    app[wmForeignTime.httpMethod](wmForeignTime.endpoint, wmForeignTime.execFn);

}

module.exports= app;